
<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<style>

body{
  max-width: 800px;
  margin: 0px auto;
}

section {
  background: white;
  font-family: monospace;
  height: 150px;
  opacity: .1;
}

section.active{
  opacity: 1;
}

#overlay{
  position: fixed;
  height: 150px;
  border-bottom: lightgray 1px solid;
  z-index: 1;
}

#overlay-space{
  height: 150px;
  content: ".";
  display: block;
  width: 800px;
}

circle{
  fill: rgb(255, 217, 159);
  stroke: black;
}

.area{
  stroke: white;
}

</style>

<div id='overlay'></div>
<div id='overlay-space'></div>

<section style="text-align:center;">
  
  intro about maps?

  <h1>Linear Scale</h1>
  Coloring maps can be tricky! Here is some advice on it. We start with an array of places, coloring them based on their locations:

      `placePaths.style('fill', function(d){ return color(x.value) })`

  `d3.scale.linear` uses linear interpolation to transform a value the domain into the range. This isn't a method
</section>

<section style="text-align:center;">
  <h1>Quantize</h1>
  some text about the top right
</section>

<section style="text-align:center;">
  <h1>Doesn't work great with outliers</h1>
  some text about the top right
</section>

<section style="text-align:center;">
  <h1>Quantile</h1>
  some text about the top right
</section>

<section style="text-align:center;">
  <h1>Might distort underlying date</h1>
  some text about the top right
</section>

<section style="text-align:center;">
  <h1>Janx natural breaks</h1>
  some text about the top right
</section>

<div id='bot-padding'></div>

<script src="d3.v3.js"></script>
<script src="gscroll.js"></script>
<script>

var width = 750,
    oHeight = 150,
    sHeight = 100,
    sWidth = 150,

    colors = ["#f2f0f7","#cbc9e2","#9e9ac8","#756bb1","#54278f"],
    scroll = gscroll(),
    n = 50,
    circleX = d3.scale.linear().domain([0, n - 1]).range([0, sWidth]),
    circleY = d3.scale.linear().range([sHeight, 0]),
    ƒ = function(s){ return function(o){ return o[s] } }

var steps = [
  {scale: 'gradient', values: 'start'},
  {scale: 'quantize', values: 'start'},
  {scale: 'quantize', values: 'quantizeFlaw'},
  {scale: 'quantile', values: 'quantizeFlaw'},
  {scale: 'quantile', values: 'quantileFlaw'},
  {scale: 'janx',     values: 'quantileFlaw'}
]

var values = {}
values.start = d3.range(n).map(function(){
  return Math.random() }).sort()
values.quantizeFlaw = d3.range(n).map(function(d){
  return Math.random() }).sort()
values.quantileFlaw = d3.range(n).map(function(d){
  return Math.random() }).sort()

var rectAttrs = {}
rectAttrs.gradient = function(selection){
  selection
    .attr('x', 0)
    .attr('width', sWidth)
    .attr('y', function(d, i){ return (colors.length - 1 - i)*sHeight/colors.length })
    .attr('height', sHeight/colors.length)
}
rectAttrs.quantize = function(selection){
  selection
    .attr('x', 0)
    .attr('width', sWidth)
    .attr('y', function(d, i){ return (colors.length - 1 - i)*sHeight/colors.length })
    .attr('height', sHeight/colors.length)
}
rectAttrs.quantile = function(selection){
  selection
    .attr('x', function(d, i){ return i*sWidth/colors.length })
    .attr('width', sWidth/colors.length)
    .attr('y', 0)
    .attr('height', sHeight)
}
rectAttrs.janx = function(selection){
  selection
    .attr('x', function(d, i){ return i*sWidth/colors.length })
    .attr('width', sWidth/colors.length)
    .attr('y', 0)
    .attr('height', sHeight)
}

var scales = {}
scales.gradient = d3.scale.linear().range([colors[0], colors[colors.length - 1]])
scales.quantize = d3.scale.quantize().range(colors)
scales.quantile = d3.scale.quantile().range(colors)
scales.janx = d3.scale.quantize().range(colors)


d3.select('#bot-padding')
    .style('height', window.innerHeight - oHeight - sHeight - 100 + 'px')


var svg = d3.select('#overlay')
  .append('svg')
    .attr({width: 800, height: oHeight})

var gradScale = d3.scale.linear()
    .domain([0, colors.length])
    .range([colors[0], colors[colors.length - 1]])
svg.append('defs').selectAll('linearGradient')
    .data(colors).enter()
  .append('linearGradient')
    .attr({x1: 0, x2: 0, y1: 1, y2: 0})
    .each(function(d, i){
      d3.select(this).attr('id', 'lg' + i)
        .append('stop')
          .datum({gradColor: gradScale(i), discColor: colors[i]})
          .attr({'stop-color': gradScale(i), offset: '0%'})
      d3.select(this).append('stop')
          .attr({'stop-color': gradScale(i + 1), offset: '100%'})
          .datum({gradColor: gradScale(i + 1), discColor: colors[i]})
    })

//backing rect
svg.append('rect').attr({width: width, height: oHeight})
    .style('fill', 'rgb(250, 248, 248)')

var mapG = svg.append('g')
    .attr('transform', 'translate(' + (width - 50 - sWidth) + ',' + (oHeight - sHeight)/2 + ')')

//scatter plot
var scatterG = svg.append('g')
    .attr('transform', 'translate(' + 50 + ',' + (oHeight - sHeight)/2 + ')')

var rects = scatterG.selectAll('rect')
    .data(colors).enter()
  .append('rect')
    .attr('fill', function(d, i){ return 'url(#lg' + i + ')' })
    .call(rectAttrs.gradient)

var circles = scatterG.selectAll('circle')
    .data(values.start).enter()
  .append('circle')
    .attr('r', 2)
    .attr('cx', function(d, i){ return circleX(i) })
    .attr('cy', circleY)

//map
d3.select('defs').append('clipPath').attr('id', 'mapclip')
  .append('rect')
    .attr({width: sWidth, height: sHeight})
var points = d3.range(n).map(function(d){
  return {x: Math.random()*sWidth, y: Math.random()*sHeight} })
mapG.append('g')
    .selectAll('area')
    .data(d3.geom.voronoi().x(ƒ('x')).y(ƒ('y'))(points)).enter()
  .append('path').classed('area', true)
.attr('clip-path', 'url(#mapclip)')
    .attr('d', function(d){
      return 'M' + d.join('L') })
mapG.selectAll('circle')
    .data(points).enter()
  .append('circle')
    .attr('r', 2)
    .attr('cx', ƒ('x'))
    .attr('cy', ƒ('y'))

var curValues, curRect, curScaleStr, curScale
scroll.on('active', function(i){
  curValues = values[steps[i].values]
  curScaleStr = steps[i].scale
  curRect = rectAttrs[curScaleStr]
  curScale = scales[curScaleStr]

  if (curScaleStr === 'quantile') curScale.domain(curValues)
  if (curScaleStr === 'janx')     curScale.domain(curValues)

  circles.data(curValues)
    .transition().duration(1000)
      .attr('cy', circleY)

  rects
    .transition().duration(1000)
      .call(curRect)

  d3.selectAll('.area').data(curValues)
    .transition().duration(1000)
      .attr('fill', function(d, i){ return curScale(curValues[i]) })

  svg.selectAll('stop')
    .transition().duration(1000)
      .attr('stop-color', ƒ(i ? 'discColor' : 'gradColor'))

})

</script>